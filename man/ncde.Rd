% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ncde.R
\name{ncde}
\alias{ncde}
\title{Neighborhood based crowding Differential Evolution (NCDE)  for multimodal optimization}
\usage{
ncde(fn, lower, upper, control = list(), ...)
}
\arguments{
\item{fn}{objective function that should be maximized. Should not return \code{NaN}.}

\item{lower}{lower bound.}

\item{upper}{upper bound.}

\item{control}{control parameters for the algorithm. See "Details".}

\item{...}{extra arguments are passed to \code{fn}.}
}
\value{
a list contains:
\describe{
  \item{\code{pop}}{a matrix; position of the population.}
  \item{\code{popval}}{a vector; corresponding population values.}
  \item{\code{nfeval}}{number of function evaluations.}
  \item{\code{maxima}}{position of particles after using \code{L-BFGS-B} when \code{control$hybrid = TRUE}. It should be local maxima. If \code{control$hybrid == FALSE}, then it is \code{NA}.}
  \item{\code{maximaval}}{fitness values of \code{maxima}.}
}


The concept of
niching is inspired by the way organisms evolve in nature.
When integrated with EAs, niching involves the formation
of subpopulations within a population. Each subpopulation
aims to locate one optimal solution and together the whole
population is expected to locate multiple optimal solutions in a single run (Qu et al., 2012).\cr
}
\description{
A niching differential evolution (DE) algorithm with neighborhood mutation strategy to solve multimodal optimization problems.
}
\details{


The \code{control} argument is a list that can supply any of the following components:
\describe{
  \item{\code{iter}}{number of iterations. Defaults to \code{200}.}
  \item{\code{SF}}{F is a scale factor in \eqn{[0, 2]} used for scaling the differential vector. Defaults to \code{0.9}.}
  \item{\code{CR}}{crossover probability from \eqn{[0, 1]}. Defaults to \code{0.2}.}
  \item{\code{NP}}{Population size. Defaults to \code{10 * length(lower)}.}
  \item{\code{seed}}{random seed.}
  \item{\code{hybrid}}{logical; if true, before quiting the algorithm,  an \code{L-BFGS-B}
   search with the provided position as initial guess is done to improve the accuracy of the results.
     Defaults to \code{TRUE}. Note that no attempt is done to control the maximal number of
      function evaluations within the local search step (this can be done separately through \code{hybrid.control})
      }
   \item{\code{hybrid_control}}{List with any additional control parameters to pass on to \code{\link{stats}{optim}}
    when using \code{L-BFGS-B} for the local search. Defaults to \code{NULL}.}
}

The DE strategy is 'DE/rand/1'.\cr
}
\note{
The function is maximized.\cr


Check whether \code{fn} does not return any \code{NaN}.\cr

The only stopping rule is the number of iterations.\cr

The implemented algorithm here slightly differs from the original
 MATLAB code in a way that the off-springs for all \code{NP} members calculated by vectorization (\code{sapply})
  and not with \code{for} loop as the original MATLAB code.
}
\examples{
####################################################################################
## Two-Peak Trap:  global maximum on x = 20 and local maximum on x = 0
two_peak <- function(x)
 y <- (160/15) * (15 - x) * (x < 15) + 40 * (x - 15) * (x >= 15)

ncde(two_peak, 0, 20, control = list(seed = 66, NP = 50))

# without local search
ncde(two_peak, 0, 20, control = list(seed = 66, NP = 50))

# without refining and local search
ncde(two_peak, 0, 20, control = list(seed = 66, NP = 50,  hybrid = FALSE))

 ####################################################################################
# Decreasing Maxima: one global on x = 0.1 and four local maxima
dmaxima <- function(x)
 y <- exp(-2 * log(2) * ((x - 0.1)/0.8)^2) * (sin(5 * pi * x))^6

res <- ncde(dmaxima, 0, 1, control = list(seed = 66, NP = 10))
unique(round(res$maxima, 5)) ## ferpsols can not find the local maxima

## plot
x <- seq(0, 1, length.out = 400)
plot(x,  dmaxima(x), type = "l")

####################################################################################
# Himmelblau's function: four global optima on
# x = c(-2.80512, 3.13131), c(3.00000, 2.00000), c(-3.77931, -3.28319) and c(3.58443, -1.84813)
Himmelblau <- function(x){
 y <- - (x[1]^2 + x[2] - 11)^2 - (x[1] + x[2]^2 - 7)^2
 return(y)
}


res <- ncde(Himmelblau, c(-6, -6), c(6, 6), control = list(seed = 66, NP = 50))
unique(round(res$maxima, 5))


Himmelblau_plot <- function(x, y)
 Himmelblau(x = c(x, y))
Himmelblau_plot <- Vectorize(Himmelblau_plot)
x <- y <- seq(-6, 6, length.out = 100)
persp(x, y, z = outer(X = x, Y = y, FUN = Himmelblau_plot))

####################################################################################
# Six-Hump Camel Back: two global and two local maxima
Six_Hump <- function(x){
 factor1 <- (4 - 2.1 * (x[1]^2) + (x[1]^4)/3) * (x[1]^2) + x[1] * x[2]
 factor2 <- (-4 + 4 * (x[2]^2)) * (x[2]^2)
 y <- -4 * (factor1 + factor2)
 return(y)
}
res <- ncde(Six_Hump, c(-1.9, -1.1), c(1.9, 1.1), control = list(seed = 66, NP = 10))
unique(round(res$maxima, 5))

####################################################################################
## 2D Inverted Shubert function :
# The global minima: 18 global minima  f(x*) = -186.7309.
# the local maxima: sevral

Shubert <- function(x){
   j <- 1:5
   out <- -(sum(j * cos((j + 1) * x[1] + j)) * sum(j * cos((j + 1) * x[2] + j)))
   return(out)
}

res <- ncde(Shubert, rep(-10, 2), rep(10, 2), control = list(seed = 66, NP = 70))
unique(round(res$maxima, 5)) ## all global maxima but not local maxima

## plotting
Shubert_plot <- function(x, y)
 Shubert(x = c(x, y))
Shubert_plot <- Vectorize(Shubert_plot)
y <- x <- seq(-10, 10, length.out = 40)
persp(x, y, z = outer(X = x, Y = y, FUN =Shubert_plot))
}
\references{
Qu, B. Y., Suganthan, P. N., & Liang, J. J. (2012). Differential evolution with neighborhood mutation for multimodal optimization. IEEE transactions on evolutionary computation, 16(5), 601-614.\cr
 Based on a MATLAB code that can be found in Suganthan's home page.
}

