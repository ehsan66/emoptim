% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ferpsols.R
\name{ferpsols}
\alias{ferpsols}
\title{Fitness-Euclidean distance ratio particle swarm optimization (FER-PSO) with local search for multimodal optimization}
\usage{
ferpsols(fn, lower, upper, control = list(), ...)
}
\arguments{
\item{fn}{objective function that should be maximized. Should not return \code{NaN}.}

\item{lower}{lower bound.}

\item{upper}{upper bound.}

\item{control}{control parameters for the algorithm. See "Details".}

\item{...}{extra arguments are passed to \code{fn}.}
}
\value{
a list contains:
\describe{
  \item{\code{pbest}}{a matrix; position of the particles.}
  \item{\code{pbestval}}{a vector; corresponding fitness value of each particle.}
  \item{\code{nfeval}}{number of function evaluations.}
  \item{\code{maxima}}{position of particles after using \code{L-BFGS-B}. It should be local maxima. If \code{control$ == FALSE}, then it is \code{NA}.}
  \item{\code{maximaval}}{fitness values of \code{maxima}.}
}
}
\description{
In  FER-PSO, Fitness and Euclidean distance Ratio (FER)
is calculated based on the fitness difference and
the Euclidean distance between a particle's personal best and
other personal bests of the particles in the population. The
key advantage is that FER-PSO removes the need of prespecifying
niching parameters that are commonly required in
existing niching evolutiobary algorithms for multimodal optimization.\cr
Furthermore,  a local search technique has been used to enhance the ability to
locate most global or local optima.
}
\details{
The \code{control} argument is a list that can supply any of the following components:
\describe{
  \item{\code{swarm}}{swarm size. Defaults to \code{50}.}
  \item{\code{iter}}{number of iterations. Defaults to \code{200}.}
  \item{\code{w}}{inertia weight. Defaults to \code{0.729843788}.}
  \item{\code{c1}}{acceleration factor. Defaults to \code{2.05}.}
  \item{\code{c2}}{acceleration factor. Defaults to \code{2.05}.}
  \item{\code{local}}{logical; local search should be performed? Defaults to \code{TRUE}}
  \item{\code{vectorize_local}}{logical; vectorization for local search? Defaults to \code{TRUE}.}
  \item{\code{seed}}{random seed.}
  \item{\code{hybrid}}{logical; if true, before quiting the algorithm,  an \code{L-BFGS-B}
   search with the provided position as initial guess is done to improve the accuracy of the results.
     Defaults to \code{TRUE}. Note that no attempt is done to control the maximal number of
      function evaluations within the local search step (this can be done separately through \code{hybrid.control})
      }
   \item{\code{hybrid_control}}{List with any additional control parameters to pass on to \code{\link{stats}{optim}}
    when using \code{L-BFGS-B} for the local search. Defaults to \code{NULL}.}
}
}
\note{
The function is maximized.\cr

Check whether \code{fn} does not return any \code{NaN}.\cr

The only stopping rule is the number of iterations.
}
\examples{
####################################################################################
## Two-Peak Trap:  global maximum on x = 20 and local maximum on x = 0
two_peak <- function(x)
 y <- (160/15) * (15 - x) * (x < 15) + 40 * (x - 15) * (x >= 15)

ferpsols(two_peak, 0, 20, control = list(seed = 66, swarm = 50))

# without local search
ferpsols(two_peak, 0, 20, control = list(seed = 66, swarm = 50))

# without refining and local search
ferpsols(two_peak, 0, 20, control = list(seed = 66, swarm = 50,  hybrid = FALSE))

 ####################################################################################
# Decreasing Maxima: one global on x = 0.1 and four local maxima
dmaxima <- function(x)
 y <- exp(-2 * log(2) * ((x - 0.1)/0.8)^2) * (sin(5 * pi * x))^6

res <- ferpsols(dmaxima, 0, 1, control = list(seed = 66, swarm = 100))
unique(round(res$maxima, 5)) ## ferpsols can not find the local maxima

## plot
x <- seq(0, 1, length.out = 400)
plot(x,  dmaxima(x), type = "l")

####################################################################################
# Himmelblau's function: four global optima on
# x = c(-2.80512, 3.13131), c(3.00000, 2.00000), c(-3.77931, -3.28319) and c(3.58443, -1.84813)
Himmelblau <- function(x){
 y <- - (x[1]^2 + x[2] - 11)^2 - (x[1] + x[2]^2 - 7)^2
 return(y)
}


res <- ferpsols(Himmelblau, c(-6, -6), c(6, 6), control = list(seed = 66, swarm = 50))
unique(round(res$maxima, 5))

Himmelblau_plot <- function(x, y)
 Himmelblau(x = c(x, y))
Himmelblau_plot <- Vectorize(Himmelblau_plot)
x <- y <- seq(-6, 6, length.out = 100)
persp(x, y, z = outer(X = x, Y = y, FUN = Himmelblau_plot))

####################################################################################
# Six-Hump Camel Back: two global and two local maxima
Six_Hump <- function(x){
 factor1 <- (4 - 2.1 * (x[1]^2) + (x[1]^4)/3) * (x[1]^2) + x[1] * x[2]
 factor2 <- (-4 + 4 * (x[2]^2)) * (x[2]^2)
 y <- -4 * (factor1 + factor2)
 return(y)
}
res <- ferpsols(Six_Hump, c(-1.9, -1.1), c(1.9, 1.1), control = list(seed = 66, swarm = 200))
unique(round(res$maxima, 5)) ## can not find the local maxima

####################################################################################
## 2D Inverted Shubert function :
# The global minima: 18 global minima  f(x*) = -186.7309.
# the local maxima: sevral

Shubert <- function(x){
   j <- 1:5
   out <- -(sum(j * cos((j + 1) * x[1] + j)) * sum(j * cos((j + 1) * x[2] + j)))
   return(out)
}

res <- ferpsols(Shubert, rep(-10, 2), rep(10, 2), control = list(seed = 66, swarm = 200))
unique(round(res$maxima, 5)) ## only the global maxima are found

## plotting
Shubert_plot <- function(x, y)
 Shubert(x = c(x, y))
Shubert_plot <- Vectorize(Shubert_plot)
y <- x <- seq(-10, 10, length.out = 40)
persp(x, y, z = outer(X = x, Y = y, FUN =Shubert_plot))
}
\references{
Qu, B. Y., Liang, J. J., & Suganthan, P. N. (2012). Niching particle swarm optimization with local search for multi-modal optimization. Information Sciences, 197, 131-143.\cr

 Li, X. (2007, July). A multimodal particle swarm optimizer based on fitness Euclidean-distance ratio. In Proceedings of the 9th annual conference on Genetic and evolutionary computation (pp. 78-85). ACM. \cr

 Based on a MATLAB code that can be found in Suganthan's home page.
}

